package Acme::CPANModules::Import::CPANRatings::User::perlancar;

# DATE
# VERSION

our $LIST = {description=>"This list is generated by scraping CPANRatings (cpanratings.perl.org) user page.",entries=>[{description=>"\nAfter the last template change of the website which is one year ago, &quot;Was this review helpful&quot; links no longer works. <a href=\"https://github.com/perlorg/perlweb/issues/232\" rel=\"nofollow\">github.com/perlorg/perlweb/issues/232</a>\r<br>\n\n",module=>"LWP::JSON::Tiny",rating=>2},{description=>"\nNo longer works. Sigh, looks like there is currently NO working generic currency converter module on CPAN anymore. Every converter module is either: 1) dead; 2) specific for some currencies only.\r<br>\n\n",module=>"Finance::Currency::Convert::WebserviceX",rating=>2},{description=>"\nUses hard-coded rates in the source code. Does not seem to work anymore: convert() returns zero even after updateRates().\n",module=>"Finance::Currency::Convert",rating=>2},{description=>"\nOf limited use because of the site's restrictive license. UPDATE: And it no longer works.\n",module=>"Finance::Currency::Convert::XE",rating=>2},{description=>"\nNo longer works (not a surprise since this module has not been updated since almost 13 years ago).\n",module=>"Finance::Currency::Convert::Yahoo",rating=>2},{description=>"\nEarly release, so not polished yet, but... cool! Thanks, Gabor. We need more CLI games!\r<br>\n\n",module=>"App::used",rating=>10},{description=>"\nThe coolest thing since PPI. Now every time someone still says that one can't parse HTML or balanced parentheses using regex, you can just point him to this module to shut him up (although, if he had said that one *shouldn't*...).\r<br><br>Also now you can say that Perl is a simple language that is easy to learn. Why? Well, it's so simple you can parse the whole syntax with a single regex.\r<br><br>\n",module=>"PPR",rating=>10},{description=>"\nUse MySQL-specific SQL dialect &quot;SHOW TABLES&quot; so comparing e.g. two SQLite database is an instant fail, even though there is DBIx::Compare::SQLite. Instead of the common convention like DBIx::Compare-&gt;new(...), uses db_comparison-&gt;new(...), sqlite_comparison-&gt;new(...), etc.\n",module=>"DBIx::Compare",rating=>4},{description=>"\nHey, Perl::Critic has not been reviewed for quite a while...\r<br><br>Finally take the plunge (again) to include Perl::Critic in my development work, this time adding critic test in the Dist::Zilla release process. Already caught a couple of stupid bugs otherwise uncaught by perl's -w. Aside from that, will help you become more consistent and a better (Perl) programmer. Invaluable! \n",module=>"Perl::Critic",rating=>10},{description=>"\nRequires perl 5.20 for no particular reason. Claims to be replacement of smart match but only covers string comparison. Just use List::Util's first() which is more flexible and part of the core Perl distribution, or match::smart which covers more cases.\n",module=>"Config::Perl",rating=>2},{description=>"\nMostly unnecessary because this is just a glorified form of a widely known Perl idiom. Requires perl 5.20 for no particular reason. Re-sorts the list which is 99% not what user wants. Just use List::Util's uniq() which is faster and part of core distribution.\n",module=>"Array::Unique",rating=>2},{description=>"\nHas some problems, e.g. it uses InstallTool phase so it conflicts with DZP:StaticInstall when wanting to produce a static install distro. Use alternatives like the simpler DZP:Pod2Readme or the more complex DZP:ReadmeAnyFromPod.\r<br>\n\n",module=>"Dist::Zilla::Plugin::ReadmeFromPod",rating=>2},{description=>"\nGreat for debugging. Just whip up some code in dist.ini to e.g. dump &amp; print some stuffs, etc.\n",module=>"Dist::Zilla::Plugin::Hook",rating=>10},{description=>"\nInteresting features, but mooseware.\n",module=>"File::Tail::Dir",rating=>6},{description=>"\nHappily returns result when graph is cyclic (and thus proper topological sorting cannot be done). See also Data::Graph::Util for a simpler alternative.\r<br>\n\n",module=>"Algorithm::Dependency",rating=>6},{description=>"\n(Reviewing Sort::Topological, which is included in Data-Match distribution at the time of this review).\r<br><br>Hangs when given a dependency like: a =&gt; [&quot;a&quot;]. Happily returns result when graph is cyclic (and thus proper topological sorting cannot be done). See also Data::Graph::Util for alternative.\r<br>\n\n",module=>"Data::Match",rating=>4},{description=>"\nFile::Find lacks the &quot;making easy things easy&quot; part, so modules like this are great. A further step would be an option to omit \$wanted for even simpler cases, but that would probably break the interface. Another alternative is File::Finder, but it forces OO style.\r<br>\n\n",module=>"File::Find::Wanted",rating=>8},{description=>"\nTo get the ratings for a single distribution, this client library needs to download /csv/all_ratings.csv (~80KB at the time of this writing) first. This is not the fault of the client because the website indeed does not provide the necessary ratings data on the /dist/:DISTNAME page. The client library should perhaps cache the CSV response though. The implementation could also be simplified by using slimmer libraries for this simple scraping task. But other than that, does what it says on the tin.\n",module=>"Hash::MD5",rating=>8},{description=>"\nNot as useful as the name implies. It requires you to download the CSV of all ratings first, which BTW does not seem to be advertised on the CPAN Ratings website. The CSV file only contains numeric ratings and does not include any reviews. So basically what this module does is just filter the CSV rows for a distribution's rating.\r<br><br>One might want to look at WWW::CPANRatings instead.\n",module=>"Parse::CPAN::Ratings",rating=>6},{description=>"\nMy new favorite Levenshtein distance module. It's as fast (if not faster) than Text::Levenshtein::XS and can provide a speed boost if you don't care about distances above a certain limit. Which I think in many cases is true.\n",module=>"Acme::Curse",rating=>10},{description=>"\nAside from being Moo-based (which, makes it a bit more heavyweight and with more dependencies), doesn't yet offer anything extra or more methods compared to previously existing modules like NetAddr::MAC.\n",module=>"CPAN::Changes",rating=>4},{description=>"\nCool. Now you can create your own Camel Code with ease!\n",module=>"Acme::AsciiArtinator",rating=>10},{description=>"\nI'd say in terms of footprint and runtime performance, this module is average (it's not the most lightweight nor the fastest pure-perl object system, not to mention against XS ones). See my Bencher::Scenarios::Accessors for a comparison, e.g. <a href=\"https://metacpan.org/pod/Bencher::Scenario::Accessors::Get\" rel=\"nofollow\">metacpan.org/pod/Bencher::Scenario::A...</a> and <a href=\"https://metacpan.org/pod/Bencher::Scenario::Accessors::Set\" rel=\"nofollow\">metacpan.org/pod/Bencher::Scenario::A...</a> .\r<br><br>One drawback of using Mojo::Base and Object::Simple is its similar but slightly different and incompatible syntax with the Moo* family, so your code is not &quot;upgradable&quot; to Moo or Moose once you need more features. And often you'll end up wanting them, e.g. one day you'll probably read about the wonders of method modifiers (before, after, around), or roles, or wanting to have a lazy constructor, or triggers, and so on.\r<br><br>I'd recommend instead Mo. It's more lightweight than Object::Simple and you can do default value, builder, ro/rw, required, even coercion. But the features are modular and you only pay for what you use. And once you need more features later, you normally should be able to just replace 'use Mo' in your code with 'use Moo' or 'use Moose'.\r<br><br>Of course, this point is moot if you don't care about compatibility/upgradability to Moo*.\n",module=>"Object::Simple",rating=>6},{description=>"\nNice. API is more convenient to use than Test::Requires, especially if you use subtests.\r<br>\n\n",module=>"Test::Needs",rating=>10},{description=>"\nReview for 0.02: Performance-wise, still has some catching up to do against JSON::XS &amp; Cpanel::JSON::XS with regards to encoding arrays &amp; hashes.\r<br><br>UPDATE review for 0.19: Giving it 4 stars now. Speed has been improving and on-par/slightly better than the other JSON XS modules in some areas, while a bit worse in some other areas. Faster modules are always welcome.\n",module=>"HTTP::Command::Wrapper",rating=>8},{description=>"\nI can see the value of Exporter::Easy (although these days the saving in typing is not as big, with plain Exporter one can just say: use Exporter 'import'; our \@EXPORT = qw(a b c)).\r<br><br>However I fail to see the value of Exporter::Easiest. I'd rather use plain Perl than some DDL which cannot be checked statically or cannot be syntax-highlighted, just to save some []'s and ()'s (which I can get my editor to help me type them).\r<br><br>In short, I'd rather use plain Exporter than save a few keystrokes but add a non-core dependency.\n",module=>"Set::Scalar",rating=>6},{description=>"\nDue to parallel processes and defaulting on no_test, can be several times faster than cpanminus (tried installing a module on a vanilla perlbrew instance with local CPAN mirror, which pulled +- 200 distributions, &quot;cpanm -n&quot; took 2m9s, while cpm took 38s.) I hope this gets developed further. Great job.\r<br>\n\n",module=>"App::cpm",rating=>10},{description=>"\nFrom the doc: &quot;This module generates one's Chinese zodiac. However, for those born in late January to early February, it may be wrong.&quot; Well, a module that might return wrong results is not very useful.\r<br>\n\n",module=>"Zodiac::Chinese",rating=>2},{description=>"\nI guess if you want to switch JSON implementation more easily with JSON, JSON::PP, and JSON::XS, it's better to use JSON::Tiny::Subclassable instead of JSON::Tiny, because the interface is more similar to JSON{::XS,::PP}, although it's not exactly the same. JT:Subclassable also supports pretty() which is often used when debugging. In short, I found JSON::Tiny::Subclassable is a better &quot;Tiny JSON&quot; module than JSON::Tiny.\n",module=>"JSON::MultiValueOrdered",rating=>10},{description=>"\nProvides some more features compared to Carp::Always, like producing stack trace even when exception is ref/object, color &amp; dump function arguments (so you don't need a separate Carp::Always::Dump and Carp::Always::Color). Recommended.\r<br>\n\n",module=>"JSON::Tiny",rating=>10},{description=>"\nNot perfect or exhaustive, but good enough and lightweight. With a dead-simple interface. Just the sort of libraries that are reusable almost everywhere. Thanks for this.\r<br><br>Also, this might not be immediately obvious since there's no mention on the See Also section: to go the other way (converting English noun from singular to plural) you can use Lingua::EN::Inflect.\n",module=>"Carp::Always",rating=>10},{description=>"\nNot as easy as the name might claim. First of all, why do users need to pass __LINE__ explicitly for every call??? Other logging modules will get this information automatically via caller(). \r<br><br>Levels are a bit confusing: why is debug split to 2 (or 3)? \r<br><br>Not as flexible as it should be because the design conflates some things together. For example, most levels output to STDERR but some level (VERBOSE) outputs to STDOUT instead. The output concern and levels should've been separated. Another example would be the DEBUGWAIT level, where level is DEBUG *and* execution is halted (wait on a keypress) on log. What if users want a lower level setting *but* want execution to be halted on log? The halt/keypress setting should've been separated from the level.\n",module=>"Log::Declare",rating=>4},{description=>"\nWho'da thought that something as seemingly simple as &quot;slurping a file into a string&quot; would need several modules and false starts? Well, if you add encodings, Perl I/O layers, scalar/list context, DWIM-ness, ... it can get complex and buggy. I'm glad there are people taking care of this and making sure that a simple task stays simple and correct. \n",module=>"File::Slurper",rating=>10},{description=>"\nA significantly faster alternative to Perl::PrereqScanner. It's *almost* a drop-in replacement, there might still be some bugs in missing detecting some modules, and you still have to do several add_extra_scanner() calls like \$scanner-&gt;add_extra_scanner('Moose') to match the behavior of Perl::PrereqScanner.\r<br><br>\n",module=>"File::Slurp",rating=>10},{description=>"\nFirst file rotating module I found and tried. Works, but needs to be modernized a bit. Indirect object notation in doc should be replaced. Bool option takes &quot;yes&quot; or &quot;no&quot;, should perhaps be 1 or 0. Capitalization adjustment, perhaps.\r<br><br>\n",module=>"Logfile::Rotate",rating=>6},{description=>"\nAt the time of this review, I find two modules for reading a file backwards: File::Bidirectional (FBidi) and File::ReadBackwards (FRB).\r<br><br>Both modules have roughly the same footprint and minimal dependencies. Both provide OO as well as tie interface. Both respect the \$/ setting.\r<br><br>FRB pro's:\r<br>\n- FRB is 15-20% faster than FBidi when reading backwards;\r<br><br>FRB con's:\r<br>\n- does not offer the feature of reading forward as well, but of course this is not the goal of the module.\r<br><br>FBidi's POD contains information on benchmarks (it's roughly an order of magnitude slower than raw Perl's open+read/diamond operator, still the case in 2014). While FRB's POD contains information on how the thing works behind the scenes.\r<br><br>In summary, both modules are roughly the same. I'd prefer FRB unless in the rarer cases where I need bidirectional reading.\r<br>\n\n",module=>"File::ReadBackwards",rating=>8},{description=>"\nAt the time of this review, I find two modules for reading a file backwards: File::Bidirectional (FBidi) and File::ReadBackwards (FRB).\r<br><br>Both modules have roughly the same footprint and minimal dependencies. Both provide OO as well as tie interface. Both respect the \$/ setting.\r<br><br>FBidi pro's:\r<br>\n- has the unique feature of reading backward/forward and switch direction in the middle;\r<br><br>FBidi con's:\r<br>\n- FBidi is 15-20% slower than FBidi when reading backwards;\r<br>\n- reading forward is just as slow as backward, so if you only need to read forward, obviously there's no need to use this module;\r<br><br>FBidi's POD contains information on benchmarks (it's roughly an order of magnitude slower than raw Perl's open+read/diamond operator, still the case in 2014). While FRB's POD contains information on how the thing works behind the scenes.\r<br><br>In summary, both modules are roughly the same. I'd prefer FRB unless in the rarer cases where I need bidirectional reading.\r<br>\n\n",module=>"File::Bidirectional",rating=>8},{description=>"\nThe part that makes this module convenient is that the functions return their original arguments. So when debugging (peppering dump statements), you don't have to change this:\r<br><br>return [&quot;some&quot;, \$expr];\r<br><br>to this (taking an example from another dumping module, Data::Dump):\r<br><br>my \$tmp = [&quot;some&quot;, \$expr]; dd \$tmp; return \$tmp;\r<br><br>but just this:\r<br><br>return YYY [&quot;some&quot;, \$expr];\r<br><br>This should be imitated by the other dumper functions.\n",module=>"Signal::StackTrace::CarpLike",rating=>10}],summary=>"Modules mentioned by CPANRatings user perlancar"};

1;
# ABSTRACT: Modules mentioned by CPANRatings user perlancar

=head1 DESCRIPTION

This list is generated by scraping CPANRatings (cpanratings.perl.org) user page.


